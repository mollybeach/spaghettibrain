/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
541. Reverse String II
Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.
If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.
Example 1:
Input: s = "abcdefg", k = 2
Output: "bacdfeg"
Input: s = "abcd", k = 2
Output: "bacd"

/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/
var reverseStr = function (s, k) {
  let revCount = 0;
  let half = [];
  let kk = 2 * k;
  let arr = s.split("");
  for (let i = 0; i < s.length; i++) {
    let j = i + 1;
    if (j % k === 0 && j % kk != 0) {
      let o = arr.splice(0, k);
      o.reverse();
      revCount = revCount + 1;
      half.push(...o);
    } else if (j % kk === 0) {
      let p = arr.splice(0, k);
      revCount = revCount - 1;
      half.push(...p);
    } else if (arr.length < k && revCount === 0) {
      arr.reverse();
      half.push(...arr);
      return half.join("").toString("");
    }
  }
  half.push(...arr);
  return half.join("").toString("");
};


reverseStr("hyzqyljrnigxvdtneasepfahmtyhlohwxmkqcdfehybknvdmfrfvtbsovjbdhevlfxpdaovjgunjqlimjkfnqcqnajmebeddqsgl",
39);
var reverseStr = function(s, k) {
    let ans = "";
    for(let i = 0; i < s.length; i+=2*k){
     if (i != 0) {
        ans = ans.substring(0, i)
            + s.substring(i , i+k).split("").reverse().join("") 
            + s.substring(i+k, s.length);
     } else{
         ans = s.substring(i , i+k).split("").reverse().join("") 
                + s.substring(i+k, s.length)
     }
    }
 return ans;
};
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
541. Reverse String II
Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.
If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.
Example 1:
Input: s = "abcdefg", k = 2
Output: "bacdfeg"
Input: s = "abcd", k = 2
Output: "bacd"

/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var reverseStr = function(s, k) {
  for(const i in s){
  if(i>k){k.pop();}
  }
  
   return k
};
reverseStr(Input: s = "abcdefg", k = 2)
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
704. Binary Search
Easy
  Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.You must write an algorithm with O(log n) runtime complexity.
Example 1:
  Input: nums = [-1,0,3,5,9,12], target = 9
  Output: 4
  Explanation: 9 exists in nums and its index is 4
Example 2:
  Input: nums = [-1,0,3,5,9,12], target = 2
  Output: -1
  Explanation: 2 does not exist in nums so return -1
*/
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/

709. To Lower Case
Easy
Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.

Example 1:
Input: "Hello"
Output: "hello"

Example 2:
Input: "here"
Output: "here"
Example 3:

Input: "LOVELY"
Output: "lovely"
*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var toLowerCase = function(str) {
   return str.toLowerCase();
};
toLowerCase("Hello");
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

var search = function(nums, target) {
  let ans;
 nums.find(function(element, index){
    if(nums[index] === target){
      ans=index
    }
  })
if(ans===undefined){ ans=-1}
return ans
};
search(nums = [-1,0,3,5,9,12], target = 9)

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*819. Most Common Word
Easy
Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.The words in paragraph are case-insensitive and the answer should be returned in lowercase.
Example 1:
Input: paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.", banned = ["hit"]
Output: "ball"

Explanation: 
"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. 
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as "ball,"), 
and that "hit" isn't the answer even though it occurs more because it is banned.

Example 2:
Input: paragraph = "a.", banned = []
Output: "a"
 
Constraints: 1 <= paragraph.length <= 1000
paragraph consists of English letters, space ' ', or one of the symbols: "!?',;.".
0 <= banned.length <= 100
1 <= banned[i].length <= 10
banned[i] consists of only lowercase English letters.

/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var checkIfPangram = function (sentence) {
  let alphabet = 'abcdefghijklmnopqrstuvwxyz';
  for (const letter in alphabet) {
   if (sentence.indexOf(alphabet[letter]) < 0) {
     return false;
    }
  }
  return true
};
checkIfPangram("thequickbrownfoxjumpsoverthelazydog");
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1108. Defanging an IP Address
Easy
Given a valid (IPv4) IP address, return a defanged version of that IP address.
A defanged IP address replaces every period "." with "[.]".
Example 1:

Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"
Example 2:

Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"
}
Constraints: The given address is a valid IPv4 address.
*/

*/
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var defangIPaddr = function (address) {
  return address.replace(/\./g, "[.]");
};
defangIPaddr("255.100.50.0");
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

var mostCommonWord = function (paragraph, banned) {
  let obj = {};
  let mostCommon;
 let wordArr = paragraph.toLowerCase().replace(/(~|`|!|@|#|$|%|^|&|\*|\(|\)|{|}|\[|\]|;|:|\"|'|<|,|\.|>|\?|\/|\\|\||-|_|\+|=)/g," ").split(" ");
  let bannedSet = new Set();
  banned.forEach((e) => bannedSet.add(e));
  let result = wordArr.filter(Boolean).filter((x) => !bannedSet.has(x));
  let counter = (key) => (obj[key] = ++obj[key] || 1);
  result.forEach(counter);
  let topWordLength = Math.max(...Object.values(obj));
  let findMatch = (key) => obj[key] === topWordLength ? (mostCommon = key) : false;
  result.forEach(findMatch);
  return mostCommon
};
mostCommonWord("Bob hit a ball, the hit BALL ball flew far after it was hit.", ['hit']);
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1200. 
Difficulty: EASY
Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. 

Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows
a, b are from arr
a < b
b - a equals to the minimum absolute difference of any two elements in arr
 

Example 1:
Input: arr = [4,2,1,3]
Output: [[1,2],[2,3],[3,4]]
Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.

Example 2:
Input: arr = [1,3,6,10,15]
Output: [[1,3]]

Example 3:
Input: arr = [3,8,-10,23,19,-4,-14,27]
Output: [[-14,-10],[19,23],[23,27]]
 
Constraints:

2 <= arr.length <= 10^5
-10^6 <= arr[i] <= 10^6
*/
*/

/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

takes too long 
var minimumAbsDifference = function(arr) {
  let diff;
  let obj={};
  let pairs;
  arr.sort(function(a, b){return a-b}); 
for(let i=0; i<arr.length; i++){
  for(let j=i+1; j<arr.length; j++){
   diff=Math.abs(arr[i]-(arr[j]));
   obj[[arr[i], arr[j]]]=diff;
   if(i===0 && j===1){
     curr=diff
   }
    if(diff<curr){
      curr=diff
      }
}
}
    Object.keys(obj).forEach((key)=> obj[key]!=curr ? delete obj[key] : false);
   pairs = Array.from((Object.keys(obj)), e => e.split(','));
     let pairsNums = pairs.map((x) => x.map((y) => +y));
     return pairsNums
};

//minimumAbsDifference([1,3,6,10,15])
minimumAbsDifference([3,8,-10,23,19,-4,-14,27])
//minimumAbsDifference([4,2,1,3])

//actual answervar minimumAbsDifference = function (arr) {
  let diff;
  let curr;
  let newArr = [];
  arr.sort(function (a, b) {
    return a - b;
  });
  for (let i = 0; i < arr.length; i++) {
    diff = Math.abs(arr[i] - arr[i + 1]);
    if (i === 0) {
      curr = diff;
    }
    if (diff < curr) {
      curr = diff;
      newArr = [[arr[i], arr[i + 1]]];
    } else if (diff === curr) {
      newArr.push([arr[i], arr[i + 1]]);
    }
  }
  return newArr;
};

minimumAbsDifference([3,8,-10,23,19,-4,-14,27])
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1470. Shuffle the Array
Easy
  Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].
  Return the array in the form [x1,y1,x2,y2,...,xn,yn].
Example 1:
  Input: nums = [2,5,1,3,4,7], n = 3
  Output: [2,3,5,4,1,7] 
  Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7].
Example 2:
  Input: nums = [1,2,3,4,4,3,2,1], n = 4
  Output: [1,4,2,3,3,2,4,1]
Example 3:
  Input: nums = [1,1,2,2], n = 2
  Output: [1,2,1,2]
    nums.splice(0, z)
    console.log(nums)
 */
 */
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var shuffle = function(nums, n) {
    let shuffle = [];
    let j = 0;
    for (let i = 0; i < n; i++) {
        [shuffle[j], shuffle[j + 1]] = [nums[i], nums[n + i]];
        j += 2;
    } 
    return shuffle;
};
shuffle(nums=[2,5,1,3,4, 7], n = 3);

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/    
/*
1480. Running Sum of 1d Array

Easy
Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i])
Return the running sum of nums.

Example 1:
Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].

Example 2:
Input: nums = [1,1,1,1,1]
Output: [1,2,3,4,5]
Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].

Example 3:
Input: nums = [3,1,2,10,1]
Output: [3,4,6,16,17]
 
Constraints:
1 <= nums.length <= 1000
-10^6 <= nums[i] <= 10^6

*/
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var runningSum = function(nums) {
let sum = 0;
let runSum = [];
for(const x in nums){
sum+=parseFloat(nums[x]);
runSum.push(sum);
}
return runSum;
};



/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
1700. Number of Students Unable to Eat Lunch
Easy

The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.

The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:

If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.
Otherwise, they will leave it and go to the queue's end.
This continues until none of the queue students want to take the top sandwich and are thus unable to eat.

You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.


Example 1:

Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
Output: 0 
Explanation:
- Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].
- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].
- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].
- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].
- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].
Hence all students are able to eat.
Example 2:

Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
Output: 3
 

Constraints:

1 <= students.length, sandwiches.length <= 100
students.length == sandwiches.length
sandwiches[i] is 0 or 1.
students[i] is 0 or 1.
*/
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1528. Shuffle String
Easy
 Given a string s and an integer array indices of the same length.
 The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.
 Return the shuffled string.
Example 1:
  Input: s = "codeleet", indices = [4,5,6,7,0,2,1,3]
  Output: "leetcode"
  Explanation: As shown, "codeleet" becomes "leetcode" after shuffling.
Example 2:
  Input: s = "abc", indices = [0,1,2]
  Output: "abc"
  Explanation: After shuffling, each character remains in its position.
Example 3:
  Input: s = "aiohn", indices = [3,1,4,2,0]
  Output: "nihao"
Example 4:
  Input: s = "aaiougrt", indices = [4,0,2,6,7,3,1,5]
  Output: "arigatou"
Example 5:
  Input: s = "art", indices = [1,0,2]
  Output: "rat"
  


 */
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 


const restoreString = (s, arr) => (
    arr.reduce((accumulator, currentValue, index) => {
        accumulator[currentValue] = s[index];
        return accumulator;
    }, []).join("")
);

var restoreString = function(s, arr) {
let x = s.split('');
let result = [];
for (let i = 0; i < s.length; i++) {
  result[arr[i]] = x[i]
}
return result.join('')
};

restoreString(s = "aiohn", arr = [3,1,4,2,0])

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1790. Check if One String Swap Can Make Strings Equal
Easy
Balanced strings are those that have an equal quantity of 'L' and 'R' characters.
Given a balanced string s, split it in the maximum amount of balanced strings.
Return the maximum amount of split balanced strings.
Example 1:
  Input: s = "RLRRLLRLRL"
  Output: 4
  Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring contains same number of 'L' and 'R'.
Example 2:
  Input: s = "RLLLLRRRLR"
  Output: 3
  Explanation: s can be split into "RL", "LLLRRR", "LR", each substring contains same number of 'L' and 'R'.
Example 3:
  Input: s = "LLLLRRRR"
  Output: 1
  Explanation: s can be split into "LLLLRRRR".
Example 4:
  Input: s = "RLRRRLLRLL"
  Output: 2
  Explaination: s can be split into "RL", "RRRLLRLL", since each substring contains an equal number of 'L' and 'R'
 */
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

var balancedStringSplit = function(s) {
    let stack = [];
    let count = 0;
    let first = s[0];
    for (let i = 0; i < s.length; i++) {
        if (s[i] === first) {
            stack.push(s[i]);
        } else {
            stack.pop();
        }
        if (!stack.length) {
            count++;
            if (s[i+1]) first = s[i+1];
        };
    }
    
    return count;
};
balancedStringSplit("RLLLLRRRLR")
**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1790. Check if One String Swap Can Make Strings Equal
Easy
You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.
Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.
Example 1:
  Input: s1 = "bank", s2 = "kanb"
  Output: true
  Explanation: For example, swap the first character with the last character of s2 to make "bank".
Example 2:
  Input: s1 = "attack", s2 = "defend"
  Output: false
  Explanation: It is impossible to make them equal with one string swap.
Example 3:
  Input: s1 = "kelb", s2 = "kelb"
  Output: true
  Explanation: The two strings are already equal, so no string swap operation is required.
Example 4:
  Input: s1 = "abcd", s2 = "dcba"
  Output: false
 */
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
/*
#1
var areAlmostEqual = function (s1, s2) {
  let miss =0;
 let one = s1.split('');
  let two = s2.split('');
  one.forEach((i, j)=> i!=two[j] ? miss=miss+1 : '')
  if(miss!=2 && miss!=0) return false
let obj1 = one.reduce((acc, i) => {
     if(!acc[i]) 
     acc[i]= 0; 
     acc[i]++;                   
    return acc;   
    }, {}
   );

let obj2 = two.reduce((acc, i) => {
    if(!acc[i]) 
     acc[i]= 0; 
     acc[i]++;                   
    return acc;   
    }, {}
   );
    if(Object.keys(obj1).sort().toString()!= Object.keys(obj2).sort().toString() ){return false}
    return true
}
#2

var areAlmostEqual = function(s1, s2) {
    if(s1 === s2) return true;
    let result='';
    
    for(let i=0;i<s1.length;i++)
        if(s1[i] !== s2[i]) result += s1[i]+s2[i];        
    
    return result.length === 4 && result[0]===result[3] && result[1] === result[2];
};
#3
var areAlmostEqual = function(s1, s2) {
    if(s1 === s2) return true;
    let miss = 0;
    for(var i = 0; i < s1.length; i++) {
        if(s1[i] !== s2[i]) {
            miss++;
        }
        if(!s2.includes(s1[i])) {
            return false;
        }
    }
        return (miss === 0 || miss === 2);
};
areAlmostEqual(s1 = "bank", s2 = "bank")


/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var countStudents = function (students, sandwiches) {
  let shift = students.length * sandwiches.length;
  for (i = 0; i < shift; i++) {
    if (students[0] != sandwiches[0]) {
      students.push(students.splice(0, 1)[0]);
    } else {
      sandwiches.splice(0, 1);
      students.splice(0, 1);
    }
  }
  return students.length;
};
countStudents([0,0,0,1,1,1,1,0,0,0], [1,0,1,0,0,1,1,0,0,0]);

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/

1800. Maximum Ascending Subarray Sum

Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.

A subarray is defined as a contiguous sequence of numbers in an array.

A subarray [numsl, numsl+1, ..., numsr-1, numsr] is ascending if for all i where l <= i < r, numsi < numsi+1. Note that a subarray of size 1 is ascending.

Example 1:

Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.
Example 2:

Input: nums = [10,20,30,40,50]
Output: 150
Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.
Example 3:

Input: nums = [12,17,15,13,10,11,12]
Output: 33
Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.
Example 4:

Input: nums = [100,10,1]
Output: 100
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100
*/

/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var maxAscendingSum = function (nums) {
  let sum = 0;
  let count = [];
  for (let item = 0; item < nums.length; item++) {
    if (nums[item] < nums[item + 1] && sum >= nums[item] && nums[item] > nums[item - 1]) {
      sum += nums[item];
    } else if (nums[item] <= nums[item - 1] ||(nums[item] < nums[item + 1] && sum >= nums[item])
    ) {
      sum = nums[item];
    } else {
      sum += nums[item];
      count.push(sum);
    }
  }
  return Math.max(...count);
};

maxAscendingSum([12,17,15,13,10,11,12])
*/
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1832. Check if the Sentence Is Pangram
Easy
A pangram is a sentence where every letter of the English alphabet appears at least once.
Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.
Example 1:
Input: sentence = "thequickbrownfoxjumpsoverthelazydog"
Output: true
Explanation: sentence contains at least one of every letter of the English alphabet.
Example 2:

Input: sentence = "leetcode"
Output: false

*/

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*1848. Minimum Distance to the Target Element
Easy
Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that abs(x) is the absolute value of x.
Return abs(i - start).

It is guaranteed that target exists in nums.
Example 1:
Input: nums = [1,2,3,4,5], target = 5, start = 3
Output: 1
Explanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.

Example 2:
Input: nums = [1], target = 1, start = 0
Output: 0
Explanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.

Example 3:
Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0
Output: 0
Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.
 

Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 104 0 <= start < nums.length
target is in nums.
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
*/
var getMinDistance = function(nums, target, start) {
  let mySet = new Set();
  nums.forEach((x)=> x===start | x===target ? mySet.add(x): false);
  console.log(mySet)
};
getMinDistance([1,2,3,4,5], 5, 3)
//x===target mySet.add(x)
