/*
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
1. Two Sum
Easy
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
*/
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/
let nums = [2,4,7,15];
let target = 9;
var twoSum = function (nums, target) {
  for (let i=0; i<nums.length; i++){
    for(let j = i + 1; j<nums.length; j++) {
      if(nums[i] + nums[j] === target){
        return [i, j]
      }
    }
  }
}
twoSum(nums, target);
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
7. Reverse Integer
Easy:
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
Example 1:
Input: x = 123
Output: 321

Example 2:
Input: x = -123
Output: -321

Example 3:
Input: x = 120
Output: 21
Return: 0000000001111001
Example 4:
Input: x = 0
Output: 0

Constraints: -2 31 <= x <= 2 31 - 1
*/
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/
       
var reverse = function(x) {
  let numToString = parseFloat(x.toString().split('').reverse().join('')) *  Math.sign(x);
  let z = Math.pow(2, 31);
  if (numToString < z && numToString > -z){
   return numToString
 } 
 else{
   return 0
   }
};

let input16Bit = 65536;  //2^16 Binary Number:10000000000000000
let input16BitNeg = -65536;
let inputFloat16 = 6.5536;
let input31Bit = 2147483648; //2^31 Binary Number:10000000000000000000000000000000
let input32Bit = 2147483647; //2^32 Binary Number:1111111111111111111111111111111
let input64Bit = 18446744073709551616; //2^64 

console.log(reverse(input64Bit))
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
9. Palindrome Number
Easy 
Given an integer x, return true if x is palindrome integer.
An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.

Example 1:
Input: x = 121
Output: true
Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
Example 4:

Input: x = -101
Output: false
 
Constraints: -231 <= x <= 231 - 1
*/
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var isPalindrome = function(x) {
    if (x === parseFloat(x.toString().split('').reverse().join(''))) {
      return true 
    }
   else{
     return false
   }   
};
console.log(isPalindrome(12.21));
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
13. Roman to Integer
Easy
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer.
Example 1:

Input: s = "III"
Output: 3
Example 2:

Input: s = "IV"
Output: 4
Example 3:

Input: s = "IX"
Output: 9
Example 4:

Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 5:

Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
 
Constraints:

1 <= s.length <= 15
s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
It is guaranteed that s is a valid roman numeral in the range [1, 3999]. 

*/
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var romanToInt = function (s) {
  let symbols = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000,
  };

  let result = 0;
  for (let i = 0; i < s.length; i++) {
    if (symbols[s[i]] < symbols[s[i + 1]]) {
      result += symbols[s[i + 1]] - symbols[s[i]];
      i++;
    } else {
      result += symbols[s[i]];
    }
  }
   return result;
};
romanToInt('IV');
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/

14. Longest Common Prefix
Easy
Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string "".

Example 1:
Input: strs = ["flower","flow","flight"]
Output: "fl"
Example 2:

Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
Constraints:
1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] consists of only lower-case English letters.
*/
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var longestCommonPrefix = function(strs) {
  let prefix = strs[0];
  console.log(strs[1][3]);
   for(i =1; i < strs.length; i++){
     for (j = 0; j < prefix.length; j++) {
       if (strs[i][j] !== prefix[j]) {
         prefix = strs[i].slice(0,j)
       }
     }
    }
   return prefix
};

let arrayOfStrings =  ["flower","flow","flight"];
longestCommonPrefix(arrayOfStrings);
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
20. Valid Parentheses
Easy
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
An input string is valid if:
Open, brackets must be closed by the same type of brackets., Open brackets must be closed in the correct order.
 
Example 1:
Input: s = "()"
Output: true

Example 2:
Input: s = "()[]{}"
Output: true

Example 3:
Input: s = "(]"
Output: false

Example 4:
Input: s = "([)]"
Output: false

Example 5:
Input: s = "{[]}"
Output: true

Constraints: 1 <= s.length <= 104, s consists of parentheses only '()[]{}'.}
*/

   /*hasOwnProperty returns a boolean value indicating whether the object on which you are calling it has a property(keys) with the name of the argument.here we are checking for the opening brackets so the keys in the object
    */
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

var isValid = function (s) {
  let parenthesesObj = {
    "(": ")",
    "{": "}",
    "[": "]",
  }
  const stack = [];
  for (const item of s) {
 //checking for opening brackets
    if (parenthesesObj.hasOwnProperty(item)) {
      stack.push(item)
    } else {
      let openBracket = stack.pop();
      //ex -> parenthesesObj[{]=}
      if (item !== parenthesesObj[openBracket]) {
        return false;
      }
    }
  }
  return stack.length === 0;
};
isValid("([)]");

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*21. Merge Two Sorted Lists
Easy

Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.


Example 1:
Input: l1 = [1,2,4], l2 = [1,3,4]
Output: [1,1,2,3,4,4]
Example 2:
Input: l1 = [], l2 = []
Output: []
Example 3:
Input: l1 = [], l2 = [0]
Output: [0]
Constraints: The number of nodes in both lists is in the range [0, 50]. -100 <= Node.val <= 100
Both l1 and l2 are sorted in non-decreasing order.

*/
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

/*********OUR ANSWER *******DIDNT WORK*/
var mergeTwoLists = function(l1, l2){
let l3 = [...l1, ...l2];
l3.sort();
return l3
};
mergeTwoLists([1,5,4], [1,3,4] );


/**********FUCKED UP REAL ANSWER ********/
function ListNode(val) {
      this.val = val;
       this.next = null;
}

var mergeTwoLists = function(l1, l2) {
    let dummyHead = new ListNode(0);
    let currentNode = dummyHead; 

    while(l1 !== null && l2 !== null){

        if(l1.val < l2.val){
            currentNode.next = l1;
            l1 = l1.next
        } else {
            currentNode.next = l2
            l2 = l2.next
        }

        currentNode = currentNode.next
    }

    if(l1 !== null) {
        currentNode.next = l1;
    } else if (l2 !== null) {
        currentNode.next = l2
    }

    return dummyHead.next
}
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/

/*
26. Remove Duplicates from Sorted Array
Easy
Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Clarification:
Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}

Example 1:

Input: nums = [1,1,2]
Output: 2, nums = [1,2]
Explanation: Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the returned length.
Example 2:

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4]
Explanation: Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter what values are set beyond the returned length.
 
Constraints:

0 <= nums.length <= 3 * 104
-104 <= nums[i] <= 104
nums is sorted in ascending order.
*/
*/
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
/******THIS QUESTION IS STUPID DONT DO IT */
var removeDuplicates = function(nums) {
  var len = nums.length;
  var last = NaN;
  var count = 0;
  for (var i = 0; i < len; i++) {
    if (nums[i] !== last) {
      nums[count] = nums[i];
      last = nums[i];
      count++;
    }
  }
  return count;
};
removeDuplicates([1, 1, 2]);


/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/

/*28. Implement strStr()
Difficulty:Easy

Implement strStr().
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Clarification:
What should we return when needle is an empty string? This is a great question to ask during an interview.
For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().

Example 1:
Input: haystack = "hello", needle = "ll" [he, o]
Output: 2

Example 2:
Input: haystack = "aaaaa", needle = "bba"
Output: -1

Example 3:
Input: haystack = "", needle = ""
Output: 0
 
Constraints: 0 <= haystack.length, needle.length <= 5 * 104
haystack and needle consist of only lower-case English characters.
*/


/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

var strStr = function(haystack, needle) {
    if(needle===''){return 0}
    if(!haystack.includes(needle)) return -1
    return haystack.split(needle)[0].length;
};
strStr("hello", 'll');
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
35. Search Insert Position
Easy
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

Example 1:
Input: nums = [1,3,5,6], target = 5
Output: 2

Example 2:
Input: nums = [1,3,5,6], target = 2
Output: 1

Example 3:
Input: nums = [1,3,5,6], target = 7
Output: 4

Example 4:
Input: nums = [1,3,5,6], target = 0
Output: 0
Example 5:

Input: nums = [1], target = 0
Output: 0
 

Constraints:

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums contains distinct values sorted in ascending order.
-104 <= target <= 104
*/

/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var searchInsert = function (nums, target) {
  if (nums.includes(target)) {
    return nums.indexOf(target);
  } else {
    let bigger = nums.find((item) => item > target);
    if (bigger) {
      return nums.indexOf(bigger);
    } else {
      return nums.length;
    }
  }
};

searchInsert([1, 2, 5, 6], 3);
/**************************************************************************************/
/*************************************QUESTION********************************************/
/*******************************************************************************/
53. Maximum Subarray

Difficulty: Easy
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.

Example 2:
Input: nums = [1]
Output: 1
Example 3:

Input: nums = [5,4,-1,7,8]

Output: 23
 
Constraints: 1 <= nums.length <= 3 * 104 -105 <= nums[i] <= 105
*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var maxSubArray = function(nums) {
    let maxSoFar = nums[0];
    let max = nums[0];
    
    for(let i = 1; i < nums.length; i++){
        let current = nums[i];
        maxSoFar = Math.max(0, current + maxSoFar);
        max = Math.max(max, maxSoFar);
    }
    return max;
};


var maxSubArray = function(nums) {
    let max = Number.MIN_SAFE_INTEGER;
    let sum = 0; 
    for(let i = 0; i <nums.length; i++){
       sum += nums[i];
       max = Math.max(max,sum);
       sum = sum < 0 ? 0 : sum;
    }
    return max;
};
maxSubArray([8,-19,5,-4,20]);

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
58. Length of Last Word
Easy
Given a string s consists of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return 0.

A word is a maximal substring consisting of non-space characters only.


Example 1:
Input: s = "Hello World"
Output: 5
Example 2:

Input: s = " "
Output: 0
 

Constraints:
1 <= s.length <= 104
s consists of only English letters and spaces ' '.*/

var lengthOfLastWord = function(s) {
    return s.trim().split(" ").pop().length;
};
lengthOfLastWord("hello world  ")

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/

/*
27. Remove Element
Easy
Given an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Clarification:
Confused why the returned value is an integer but your answer is an array?
Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller as well.

Internally you can think of this:
// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
 

Example 1:
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2]
Explanation: Your function should return length = 2, with the first two elements of nums being 2.
It doesn't matter what you leave beyond the returned length. For example if you return 2 with nums = [2,2,3,3] or nums = [2,2,0,0], your answer will be accepted.
Example 2:

Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3]
Explanation: Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length.
 
Constraints: 0 <= nums.length <= 100 0 <= nums[i] <= 50 0 <= val <= 100
*/

*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var removeElement = function(nums, val) {
for(i=0; i<nums.length; i++){
  if(nums[i]===val){
    nums.splice(i, 1)
    i--;
}
}
return nums.length
};
removeElement([3,2,2,3], 2);

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*66. Plus One
Easy
Given a non-empty array of decimal digits representing a non-negative integer, increment one to the integer.
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.
You may assume the integer does not contain any leading zero, except the number 0 itself.

Example 1:
Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.

Example 2:
Input: digits = [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.

Example 3:
Input: digits = [0]
Output: [1]
 
Constraints: 1 <= digits.length <= 100 0 <= digits[i] <= 9*/

*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 


var plusOne = function (digits) {
    for (let i = digits.length - 1; i >= 0; i--) {
      switch (true) {
        case digits[i] != 9: digits[i]=digits[i] + 1; return digits;
        case i === 0:digits[i] = 1; digits.push(0);break;
        default:digits[i] = 0;
      }
    }
  return digits;
};
plusOne( [1,2,3]);

/* 
var plusOne = function (digits) {
  let isSafe = () => {
    digits = Array.from(String(+digits.join(“”) + 1), Number).map((x) => (x % 10 === 0 ? (“” + x).split(“”) : x)).flat().map((y) => +y);
  };
  let notSafe = () => {
    for (let i = digits.length - 1; i >= 0; i--) {
      switch (true) {
        case digits[i] != 9: digits[i]=digits[i] + 1; return;
        case i === 0:digits[i] = 1; digits.push(0);break;
        default:digits[i] = 0;
      }
    }
  };
  Number.isSafeInteger(+digits.join(“”)) ? isSafe() : notSafe();
  return digits;
};
plusOne([6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3]);

*/
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
67. Add Binary
Easy
Given two binary strings a and b, return their sum as a binary string.

Example 1:
Input: a = "11", b = "1"
Output: "100"

Example 2:
Input: a = "1010", b = "1011"
Output: "10101"

Constraints: 1 <= a.length, b.length <= 104
a and b consist only of '0' or '1' characters.
Each string does not contain leading zeros except for the zero itself.*/
//1100100

/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var addBinary = function(a, b) {
  const aBin = `0b${a}`;
  const bBin = `0b${b}`;
  const sum = BigInt(aBin) + BigInt(bBin)
  return sum.toString(2)
};

addBinary('11', '1')
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/* 
69. Sqrt(x)
Given a non-negative integer x, compute and return the square root of x.
Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.


Example 1:
Input: x = 4
Output: 2

Example 2:
Input: x = 8
Output: 2

Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.


Constraints: 0 <= x <= 231 - 1
    */
    
var mySqrt = function(x) {
  let sqrt = Math.sqrt(x);
  let whole = Math.floor(sqrt)
  return whole
};

mySqrt(4)



var mySqrt2 = function(x) {
  return Math.floor(x ** 0.5);
};
mySqrt2(6)
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/

70. Climbing Stairs
Easy
You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Example 1:
Input: n = 2
Output: 2
Explanation: There are two ways t

o climb to the top.
1. 1 step + 1 step
2. 2 steps

Example 2:
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
 
Constraints: 1 <= n <= 45 */


/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var climbStairs = function(n) {
if (n === 1) return 1
if (n === 0) return 0

    let one =1;
    let two=2;
    let add;
    
    for (let i = 3; i <= n; i++) {
      add = one + two;
      one = two;
      two = add;
    }

    return two
};


climbStairs(0);
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/

/*

83. Remove Duplicates from Sorted List
Easy
Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

Example 1:
Input: head = [1,1,2]
Output: [1,2]

Example 2:
Input: head = [1,1,2,3,3]
Output: [1,2,3]

Constraints:
The number of nodes in the list is in the range [0, 300].
-100 <= Node.val <= 100
The list is guaranteed to be sorted in ascending order. */

/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

/****ANSWER THAT ONLY WORKS ON REPL??? ***/
var deleteDuplicates = function(head) {
for(i=0; i<head.length; i++){
  if(head[i]===head[i+1]){
    head.splice(i, 1)
    i--;
}
}
return head
};
deleteDuplicates( [1,1,2,3,3]);
/****ANSWER THAT ONLY WORKS ON LEETCODE?? */
var deleteDuplicates = function(head) {
  if(!head || !head.next) return head;
  head.next = deleteDuplicates(head.next);
  return head.val == head.next.val ? head.next : head;
};
deleteDuplicates( [1,1,2,3,3]);
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
/*88. Merge Sorted Array
Easy

Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has a size equal to m + n such that it has enough space to hold additional elements from nums2.


/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
Example 1:
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]

Example 2:
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1] 
*/

const merge = (nums1, m, nums2, n) => {
  for (let i = nums2.length - 1; i >= 0; i--) {
    nums1.unshift(nums2[i])
    nums1.pop()
  }

  nums1.sort((a, b) => a - b)
  return nums1
}
//merge([1,2,3,0,0,0], 3, [2,5,6], 3)
//merge([1], 1, [], 0);

merge([0], 0, [1], 1);
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*94. Binary Tree Inorder Traversal
Easy
Given the root of a binary tree, return the inorder traversal of its nodes' values.

Example 1:
Input: root = [1,null,2,3]
Output: [1,3,2]
Example 2:

Input: root = []
Output: []
Example 3:

Input: root = [1]
Output: [1] */
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
const inorderTraversal = root => {
  if (!root) {
    return []
  }

  const values = []

  const traverse = (node) => {
    if (node !== null) {
      traverse(node.left)
      values.push(node.val)
      traverse(node.right)
    }
  }

  traverse(root)

  return values
}
inorderTraversal([1,null,2,3])
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*118. Pascal's Triangle
Easy

Given an integer numRows, return the first numRows of Pascal's triangle.
In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

Example 1:
Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

Example 2:
Input: numRows = 1
Output: [[1]]
 

Constraints: 1 <= numRows <= 30 */
/*let triangle = [[1], [1,1],[1, 2,1], [1, 3, 3,1], [1, 4, 6, 4,1], [1, 5, 10,10, 5, 1] ];*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

var generate = function(numRows) {
  let pascal = [];
  for (let i = 0; i < numRows; i++) {
  pascal[i] = [];
  pascal[i][0] = 1;
  pascal[i][pascal.length-1] = 1;

  for (let j = 1; j < i; j++) {
    pascal[i][j] = pascal[i-1][j-1] + pascal[i-1][j];
  }
}
  return pascal 
};
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*94. Binary Tree Inorder Traversal
Easy-Given the roo of a binary tree, return the inorder traversal of its nodes' values.

Example 1:
Input: roo = [1,null,2,3]
Output: [1,3,2]

Example 2:
Input: roo = []
Output: []

Example 3:
Input: roo = [1]
Output: [1] */

/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */


function TreeNode(val, left, right) {
  let node = {};
  node.val = val === undefined ? 0 : val;
  node.left = left === undefined ? null : left;
  node.right = right === undefined ? null : right;
  return node;
}
function inOrder(treeNode, res) {
  if (!treeNode) return res;
  inOrder(treeNode.left, res);
  res.push(treeNode.val);
  inOrder(treeNode.right, res);
  return res;
}

function arrayToTree(arr) {
  if (arr[0] === null) {
    return null;
  }
  let tree = new TreeNode(arr[0]); 
  function preOrder(currentNode, index) {
    if (currentNode == null || index >= arr.length) return index;
    let leftNode = arr[index] != null ? TreeNode(arr[index]) : null;
    let rightIndex = preOrder(leftNode, index + 1);
    currentNode.left = leftNode;
    let rightNode = rightIndex >= arr.length || arr[rightIndex] == null
        ? null
        : TreeNode(arr[rightIndex]);
    currentNode.right = rightNode; 
    return preOrder(rightNode, rightIndex + 1);
  }
  preOrder(tree, 1);
  console.log(tree)
  return tree;
}

function inorderTraversal(arr) {
  let root = arrayToTree(arr);
  return inOrder(root, []);
}

inorderTraversal([1, null, 2, 3]);

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
101. Symmetric Tree
Easy
Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
Example 1:
Input: root = [1,2,2,3,4,4,3]
Output: true
Example 2:
Input: root = [1,2,2,null,3,null,3]
Output: false
Constraints: The number of nodes in the tree is in the range [1, 1000]. -100 <= Node.val <= 100*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
function Node(val, left, right) {
  let node = {};
  node.val = val === undefined ? 0 : val;
  node.left = left === undefined ? null : left;
  node.right = right === undefined ? null : right;
  return node;
}
function arrayToTree(arr) {
  if (arr[0] === null) return null;
  function deserialize(cNode, i) {
    if (cNode == null || i >= arr.length) return i;
    let nodeL = arr[i] != null ? Node(arr[i]) : null;
    let iRight = deserialize(nodeL, i + 1);
    cNode.left = nodeL;
    let nodeR = iRight >= arr.length || arr[iRight] == null ? null : TreeNode(arr[iRight]);
    cNode.right = nodeR; 
    return deserialize(nodeR, iRight + 1);
  }
  let cNode = new Node(arr[0]); 
  deserialize(cNode, 1);
  console.log(cNode)
  return cNode;
}
function isSymmetric(root) {
  if(!root) return false;
  function isMirror(treeX, treeY) {
  if(!treeX && !treeY) return true
  if(!treeX || !treeY) return false
  return (treeX.val === treeY.val) && isMirror(treeX.left, treeY.right) && isMirror(treeX.right, treeY.left);
}
 let tree = arrayToTree(root);
 return isMirror(tree.left, tree.right); 
}

//isSymmetric([1,2,2,null,3,null,3]);
isSymmetric([1,2,2,3,4,4,3]);
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
101. Symmetric Tree
Easy
Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
Example 1:
Input: root = [1,2,2,3,4,4,3]
Output: true
Example 2:
Input: root = [1,2,2,null,3,null,3]
Output: false
Constraints: The number of nodes in the tree is in the range [1, 1000]. -100 <= Node.val <= 100*/
/*************************************************************************************/
/************************************ANSWER********************************************/

function Node(val, left, right) {
  let node = {};
  node.val = val === undefined ? 0 : val;
  node.left = left === undefined ? null : left;
  node.right = right === undefined ? null : right;
  return node;
}
function arrayToTree(arr) {
  if (arr[0] === null) return null;
  function deserialize(cNode, i) {
    if (cNode == null || i >= arr.length) return i;
    let nodeL = arr[i] != null ? Node(arr[i]) : null;
    let iRight = deserialize(nodeL, i + 1);
    cNode.left = nodeL;
    let nodeR = iRight >= arr.length || arr[iRight] == null ? null : Node(arr[iRight]);
    cNode.right = nodeR; 
    return deserialize(nodeR, iRight + 1);
  }
  let cNode = new Node(arr[0]); 
  deserialize(cNode, 1);
  return cNode;
}
function isSymmetric(root) {
  if(!root) return false;
  function isMirror(treeX, treeY) {
  if(!treeX && !treeY) return true
  if(!treeX || !treeY) return false
  return (treeX.val === treeY.val) && isMirror(treeX.left, treeY.right) && isMirror(treeX.right, treeY.left);
}
 let tree = arrayToTree(root);
 return isMirror(tree.left, tree.right); 
}

var rootNode = arrayToTree([1,2,3,null,null,4,null,null,2,4,null,null,3,null,null]);
isSymmetric(rootNode);
/*//isSymmetric([1,2,2,null,3,null,3]);
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
104. Maximum Depth of Binary Tree
Easy
A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: 3
Example 2:
Input: root = [1,2,2,null,3,null,3]
Example 3:
Input: root = []
Output: 0
Example 4:
Input: root = [0]
Output: 1
Constraints: The number of nodes in the tree is in the range [0, 104]. -100 <= Node.val <= 100*
/*************************************************************************************/
/************************************ANSWER********************************************/
function Node(val, left, right) {
  let node = {};
  node.val = val === undefined ? 0 : val;
  node.left = left === undefined ? null : left;
  node.right = right === undefined ? null : right;
  return node;
}
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}
function arrayToTree(arr) {
   if (arr[0] === null) return null;
  function deserialize(cNode, i) {
    if (cNode == null || i >= arr.length) return null;
    let nodeL = arr[i] != null ? new Node(arr[i]) : null;
    let iRight = deserialize(nodeL, i+1);
    cNode.left = nodeL;
    let nodeR = iRight >= arr.length || arr[iRight] == null
        ? null
        : new Node(arr[iRight]);
    cNode.right = nodeR;
    return deserialize(nodeR, iRight + 1);
  }
  cNode = new Node(arr[0]);
  deserialize(cNode, 1);
  return cNode;
}
function maxDepth(root) {
  console.log(arrayToTree(root))
  return findDepth(arrayToTree(root))
}
function findDepth(root) {
  return root === null ? 0 : Math.max(findDepth(root.left), findDepth(root.right)+1)
}
maxDepth([1,2,2,3,4,4,3]);
//[3,9,20,null,null,15,7] exp 3 */
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
108. Convert Sorted Array to Binary Search Tree
Easy
  Given an integer array nums where the elements are sorted in ascending order
  convert it to a height-balanced binary search tree.
  A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.
Example 1:
  Input: nums = [-10,-3,0,5,9]
  Output: [0,-3,9,-10,null,5]
  Explanation: [0,-10,5,null,-3,null,9] is also accepted:
Example 2:
  Input: nums = [1,3]
  Output: [3,1]
  Explanation: [1,3] and [3,1] are both a height-balanced BSTs.
Constraints: 1 <= nums.length <= 104 && -104 <= nums[i] <= 104 && nums is sorted in a strictly increasing order.
*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
const sortedArrayToBST = nums => {
  const createBST = (nums, start, end) => {
    if (end < start) {
      return null
    }
    const mid = Math.ceil((start + end) / 2)
    const node = new TreeNode(nums[mid])
    node.left = createBST(nums, start, mid - 1)
    node.right = createBST(nums, mid + 1, end)
    return node
  }
  return createBST(nums, 0, nums.length - 1)
}
sortedArrayToBST([-10,-3,0,5,9]);
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
108. Convert Sorted Array to Binary Search Tree
Easy
  Given an integer array nums where the elements are sorted in ascending order
  convert it to a height-balanced binary search tree.
  A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.
Example 1:
  Input: nums = [-10,-3,0,5,9]
  Output: [0,-3,9,-10,null,5]
  Explanation: [0,-10,5,null,-3,null,9] is also accepted:
Example 2:
  Input: nums = [1,3]
  Output: [3,1]
  Explanation: [1,3] and [3,1] are both a height-balanced BSTs.
Constraints: 1 <= nums.length <= 104 && -104 <= nums[i] <= 104 && nums is sorted in a strictly increasing order.
*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}
  var sortedArrayToBST = function(nums) {
      return traverse(nums,0,nums.length-1);
  };

  function traverse(nums,start,end){
      if(start>end){                         
          return null;
      }
      let mid = Math.floor((start+end)/2);       
      let root = new TreeNode(nums[mid]);         
      root.left = traverse(nums,start,mid-1);      
      root.right = traverse(nums,mid+1,end);   
      return root;                             
 }

sortedArrayToBST([0,-3,9,-10,null,5]);

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
119. Pascal's Triangle II
Easy
Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.
In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:
Example 1:
Input: rowIndex = 3
Output: [1,3,3,1]
Example 2:
Input: rowIndex = 0
Output: [1]
Example 3:
Input: rowIndex = 1
Output: [1,1]
/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/

var getRow = function(rowIndex) {
  let row = [];
  for (let i = 0; i < rowIndex+1; i++) {
  row[i] = [];
  row[i][0] = 1;
  row[i][row.length-1] = 1;
  for (let j = 1; j < i; j++) {
    row[i][j] = row[i-1][j-1] + row[i-1][j];
  }
}
  return row[rowIndex] 
};
getRow(3)
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/