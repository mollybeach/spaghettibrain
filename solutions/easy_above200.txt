
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***************************************************************************************/
/*
169. Majority Element
Easy
Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
Example 1:

Input: nums = [3,2,3]
Output: 3
Example 2:

Input: nums = [2,2,1,1,1,2,2]
Output: 2
*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/
var majorityElement = function(nums) {
    let obj = {};
    for(let i in nums){ 
      if(!obj[nums[i]]) obj[nums[i]]=1;
      else obj[nums[i]]=obj[nums[i]]+1
      }
    let max = Math.max(...Object.values(obj));    
      return  Object.keys(obj).find(key => obj[key] === max)
};
majorityElement(nums = [2,2,1,1,1,2,2])
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***************************************************************************************/
/*
238. Product of Array Except Self
Medium
Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.

Example 1:
Input: nums = [1,2,3,4]
Output: [24,12,8,6]

Example 2:
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
 console.log(arr)
 console.log(arr[ind] + '\n')
*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/

const productExceptSelf = (nums) => {
  let len = nums.length, res = Array(len).fill(1), left=1, right=1;
  for (let i = 0; i < len; i++) {
    res[i] *= left;
    res[len - 1 - i] *= right;
    left *= nums[i];
    right *= nums[len - 1 - i];
  }
  return res;
};

productExceptSelf( nums =[-1,1,0,-3,3]); 




/**************************************************************************************/
/*************************************QUESTION********************************************/
/***************************************************************************************/
/*
387. First Unique Character in a String
Easy

Given a string s, return the first non-repeating character in it and return its index. If it does not exist, return -1.
Example 1:

Input: s = "leetcode"
Output: 0
Example 2:

Input: s = "loveleetcode"
Output: 2

Example 3:
Input: s = "aabb"
Output: -1
/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/
const firstUniqChar = s => {
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) === i && s.indexOf(s[i], i + 1) === -1) {
      return i
    }
  }

  return -1
};
firstUniqChar(s = "loveleetcode");
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***************************************************************************************/
/*
415. Add Strings
Easy
Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.

You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.

Example 1:

Input: num1 = "11", num2 = "123"
Output: "134"
Example 2:

Input: num1 = "456", num2 = "77"
Output: "533"
Example 3:

Input: num1 = "0", num2 = "0"
Output: "0"
*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/
var addStrings = function(num1, num2) {
    var sum = '';
    var carry = 0;
    var num1Length = num1.length; 
    var num2Length = num2.length;
    var tempNum1;
    var tempNum2;
    var tempSum = 0;
    while(num1Length > 0 || num2Length > 0 || carry == 1){
        
        tempNum1 = num1[num1Length-1] ? num1[num1Length-1] : '0';
        tempNum2 = num2[num2Length-1] ? num2[num2Length-1] : '0';
        tempSum = parseInt(tempNum1) + parseInt(tempNum2) + carry;
        
        sum = (tempSum%10).toString() + sum;
        carry = tempSum >= 10 ? 1 : 0;  
        
        num1Length--;
        num2Length--;
    }
    
    return sum.toString();
};
addStrings("9333852702227987",
"85731737104263")
                            
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
541. Reverse String II
Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.
If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.
Example 1:
Input: s = "abcdefg", k = 2
Output: "bacdfeg"
Input: s = "abcd", k = 2
Output: "bacd"

/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/
var reverseStr = function (s, k) {
  let revCount = 0;
  let half = [];
  let kk = 2 * k;
  let arr = s.split("");
  for (let i = 0; i < s.length; i++) {
    let j = i + 1;
    if (j % k === 0 && j % kk != 0) {
      let o = arr.splice(0, k);
      o.reverse();
      revCount = revCount + 1;
      half.push(...o);
    } else if (j % kk === 0) {
      let p = arr.splice(0, k);
      revCount = revCount - 1;
      half.push(...p);
    } else if (arr.length < k && revCount === 0) {
      arr.reverse();
      half.push(...arr);
      return half.join("").toString("");
    }
  }
  half.push(...arr);
  return half.join("").toString("");
};


reverseStr("hyzqyljrnigxvdtneasepfahmtyhlohwxmkqcdfehybknvdmfrfvtbsovjbdhevlfxpdaovjgunjqlimjkfnqcqnajmebeddqsgl",
39);
var reverseStr = function(s, k) {
    let ans = "";
    for(let i = 0; i < s.length; i+=2*k){
     if (i != 0) {
        ans = ans.substring(0, i)
            + s.substring(i , i+k).split("").reverse().join("") 
            + s.substring(i+k, s.length);
     } else{
         ans = s.substring(i , i+k).split("").reverse().join("") 
                + s.substring(i+k, s.length)
     }
    }
 return ans;
};
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
541. Reverse String II
Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.
If there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.
Example 1:
Input: s = "abcdefg", k = 2
Output: "bacdfeg"
Input: s = "abcd", k = 2
Output: "bacd"

/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var reverseStr = function(s, k) {
  for(const i in s){
  if(i>k){k.pop();}
  }
  
   return k
};
reverseStr(Input: s = "abcdefg", k = 2)
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
704. Binary Search
Easy
  Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.You must write an algorithm with O(log n) runtime complexity.
Example 1:
  Input: nums = [-1,0,3,5,9,12], target = 9
  Output: 4
  Explanation: 9 exists in nums and its index is 4
Example 2:
  Input: nums = [-1,0,3,5,9,12], target = 2
  Output: -1
  Explanation: 2 does not exist in nums so return -1
*/
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/

709. To Lower Case
Easy
Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.

Example 1:
Input: "Hello"
Output: "hello"

Example 2:
Input: "here"
Output: "here"
Example 3:

Input: "LOVELY"
Output: "lovely"
*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var toLowerCase = function(str) {
   return str.toLowerCase();
};
toLowerCase("Hello");
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

var search = function(nums, target) {
  let ans;
 nums.find(function(element, index){
    if(nums[index] === target){
      ans=index
    }
  })
if(ans===undefined){ ans=-1}
return ans
};
search(nums = [-1,0,3,5,9,12], target = 9)
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***************************************************************************************/
/*
796. Rotate String
Easy

We are given two strings, s and goal.
A shift on s consists of taking string s and moving the leftmost character to the rightmost position. For example, if s = 'abcde', then it will be 'bcdea' after one shift on s. Return true if and only if s can become goal after some number of shifts on s.

Example 1:
Input: s = 'abcde', goal = 'cdeab'
Output: true

Example 2:
Input: s = 'abcde', goal = 'abced'
Output: false

Note:
s and goal will have length at most 100.
/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/

var rotateString = function (s, goal) {
  if (s===goal) return true ;
  for (let char of s) {
    s = s.slice(1) + s.slice(0, 1);   //rotating the string 
    if (s===goal) return true;
  }
  return false;
};

/*
var rotateString = function (s, goal) {
  if(s===goal) return true
  let arr = s.split('');
  for (const i in s) {
    if (arr.join("") === goal) return true;
    arr.unshift(arr.pop());
  }
  return false;
};*/
rotateString( s = 'abcde', goal = 'cdeab');
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*819. Most Common Word
Easy
Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.The words in paragraph are case-insensitive and the answer should be returned in lowercase.
Example 1:
Input: paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.", banned = ["hit"]
Output: "ball"

Explanation: 
"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. 
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as "ball,"), 
and that "hit" isn't the answer even though it occurs more because it is banned.

Example 2:
Input: paragraph = "a.", banned = []
Output: "a"
 
Constraints: 1 <= paragraph.length <= 1000
paragraph consists of English letters, space ' ', or one of the symbols: "!?',;.".
0 <= banned.length <= 100
1 <= banned[i].length <= 10
banned[i] consists of only lowercase English letters.
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***************************************************************************************/
/*
859. Buddy Strings
Easy

Given two strings a and b, return true if you can swap two letters in a so the result is equal to b, otherwise, return false.
Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at a[i] and a[j].
For example, swapping at indices 0 and 2 in "abcd" results in "cbad".

Example 1:
Input: a = "ab", b = "ba"
Output: true
Explanation: You can swap a[0] = 'a' and a[1] = 'b' to get "ba", which is equal to b.

Example 2:
Input: a = "ab", b = "ab"
Output: false
Explanation: The only letters you can swap are a[0] = 'a' and a[1] = 'b', which results in "ba" != b.

Example 3:
Input: a = "aa", b = "aa"
Output: true
Explanation: You can swap a[0] = 'a' and a[1] = 'a' to get "aa", which is equal to b.

Example 4:
Input: a = "aaaaaaabc", b = "aaaaaaacb"
Output: true
*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/
var buddyStrings = function (a, b) {
  let set = new Set(), i = 0, aNum = 0, bNum = 0, lenA = a.length, lenB = b.length, miss = 0;
  if (lenA != lenB || lenA === 0 || lenB === 0) return false;
  while (i < lenA) {
    if (a === b) {
      if (set.has(a[i])) return true;
    }
  else if(a.indexOf(b[i])===-1 || b.indexOf(a[i])===-1) return false
  else if (a[i] != b[i]) miss = miss + 1;
   aNum = aNum + a.charCodeAt(i), bNum = bNum + b.charCodeAt(i);
    set.add(a[i]);
    i++;
  }
  if (miss>2 || aNum != bNum || a===b) return false;
  else return true;
};
buddyStrings("abab","acaa");
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var checkIfPangram = function (sentence) {
  let alphabet = 'abcdefghijklmnopqrstuvwxyz';
  for (const letter in alphabet) {
   if (sentence.indexOf(alphabet[letter]) < 0) {
     return false;
    }
  }
  return true
};
checkIfPangram("thequickbrownfoxjumpsoverthelazydog");
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***************************************************************************************/
/*
942. DI String Match
Easy
A permutation perm of n + 1 integers of all the integers in the range [0, n] can be represented as a string s of length n where:

s[i] == 'I' if perm[i] < perm[i + 1], and
i must be one less than index in front of it 
d must be one greater than the one in front of it 
 d must be one less than the index behind it 
 i must be one more than the one behind it 
s[i] == 'D' if perm[i] > perm[i + 1].
Given a string s, reconstruct the permutation perm and return it. If there are multiple valid permutations perm, return any of them.

Example 1:
Input: s = 'IDID'
Output: [0,4,1,3,2]

Example 2:
Input: s = 'III'
Output: [0,1,2,3]

Example 3:
Input: s = 'DDI'
Output: [3,2,0,1]
*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/

a =[...Array(5).keys()], -> [0 , 1, 2, 3, 4]
// a =[...Array(len + 1).keys()], <--makes a copy of the indexes 
/* my answer correct
var diStringMatch=function (s) {
  let len=s.length, a =[], left=0, right=len,i=0;
  while (left <= right && i <= len) {
    if (left===right) a[i]=left;
    else if (i===0){
      if (s[i]==='D') a[i]=len, right--
      else a[i]=left, left++ }
    else {
      if (s[i]==='D') (a[i]=right), right--
      else a[i]=left, left++ }
   i++;
  }
  return a;
};

*/
/another answer 

var diStringMatch = function(s) {
    let max = s.length, min = 0, result = []
    for (let i of s){ 
        if (i === 'D'){
            result.push(max)
            max--
        }
        else if (i === 'I'){
            result.push(min)
            min++
        }
    }
    result.push(max) //pushs that remaining it could be min or max same 
    return result
};
diStringMatch( s = 'IDID')
/*
1108. Defanging an IP Address
Easy
Given a valid (IPv4) IP address, return a defanged version of that IP address.
A defanged IP address replaces every period "." with "[.]".
Example 1:

Input: address = "1.1.1.1"
Output: "1[.]1[.]1[.]1"
Example 2:

Input: address = "255.100.50.0"
Output: "255[.]100[.]50[.]0"
}
Constraints: The given address is a valid IPv4 address.
*/

*/
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var defangIPaddr = function (address) {
  return address.replace(/\./g, "[.]");
};
defangIPaddr("255.100.50.0");
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

var mostCommonWord = function (paragraph, banned) {
  let obj = {};
  let mostCommon;
 let wordArr = paragraph.toLowerCase().replace(/(~|`|!|@|#|$|%|^|&|\*|\(|\)|{|}|\[|\]|;|:|\"|'|<|,|\.|>|\?|\/|\\|\||-|_|\+|=)/g," ").split(" ");
  let bannedSet = new Set();
  banned.forEach((e) => bannedSet.add(e));
  let result = wordArr.filter(Boolean).filter((x) => !bannedSet.has(x));
  let counter = (key) => (obj[key] = ++obj[key] || 1);
  result.forEach(counter);
  let topWordLength = Math.max(...Object.values(obj));
  let findMatch = (key) => obj[key] === topWordLength ? (mostCommon = key) : false;
  result.forEach(findMatch);
  return mostCommon
};
mostCommonWord("Bob hit a ball, the hit BALL ball flew far after it was hit.", ['hit']);
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1200. 
Difficulty: EASY
Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. 

Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows
a, b are from arr
a < b
b - a equals to the minimum absolute difference of any two elements in arr
 

Example 1:
Input: arr = [4,2,1,3]
Output: [[1,2],[2,3],[3,4]]
Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.

Example 2:
Input: arr = [1,3,6,10,15]
Output: [[1,3]]

Example 3:
Input: arr = [3,8,-10,23,19,-4,-14,27]
Output: [[-14,-10],[19,23],[23,27]]
 
Constraints:

2 <= arr.length <= 10^5
-10^6 <= arr[i] <= 10^6
*/
*/

/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

takes too long 
var minimumAbsDifference = function(arr) {
  let diff;
  let obj={};
  let pairs;
  arr.sort(function(a, b){return a-b}); 
for(let i=0; i<arr.length; i++){
  for(let j=i+1; j<arr.length; j++){
   diff=Math.abs(arr[i]-(arr[j]));
   obj[[arr[i], arr[j]]]=diff;
   if(i===0 && j===1){
     curr=diff
   }
    if(diff<curr){
      curr=diff
      }
}
}
    Object.keys(obj).forEach((key)=> obj[key]!=curr ? delete obj[key] : false);
   pairs = Array.from((Object.keys(obj)), e => e.split(','));
     let pairsNums = pairs.map((x) => x.map((y) => +y));
     return pairsNums
};

//minimumAbsDifference([1,3,6,10,15])
minimumAbsDifference([3,8,-10,23,19,-4,-14,27])
//minimumAbsDifference([4,2,1,3])

//actual answervar minimumAbsDifference = function (arr) {
  let diff;
  let curr;
  let newArr = [];
  arr.sort(function (a, b) {
    return a - b;
  });
  for (let i = 0; i < arr.length; i++) {
    diff = Math.abs(arr[i] - arr[i + 1]);
    if (i === 0) {
      curr = diff;
    }
    if (diff < curr) {
      curr = diff;
      newArr = [[arr[i], arr[i + 1]]];
    } else if (diff === curr) {
      newArr.push([arr[i], arr[i + 1]]);
    }
  }
  return newArr;
};

minimumAbsDifference([3,8,-10,23,19,-4,-14,27])
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***************************************************************************************
1370. Increasing Decreasing String
Easy

Given a string s. You should re-order the string using the following algorithm:

Pick the smallest character from s and append it to the result.
Pick the smallest character from s which is greater than the last appended character to the result and append it.

Repeat step 2 until you cannot pick more characters.

Pick the largest character from s and append it to the result.
Pick the largest character from s which is smaller than the last appended character to the result and append it.

Repeat step 5 until you cannot pick more characters.
Repeat the steps from 1 to 6 until you pick all characters from s.

In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.

Return the result string after sorting s with this algorithm.

Example 1:
Input: s = "aaaabbbbcccc"
Output: "abccbaabccba"
Explanation: After steps 1, 2 and 3 of the first iteration, result = "abc"
After steps 4, 5 and 6 of the first iteration, result = "abccba"
First iteration is done. Now s = "aabbcc" and we go back to step 1
After steps 1, 2 and 3 of the second iteration, result = "abccbaabc"
After steps 4, 5 and 6 of the second iteration, result = "abccbaabccba"

Example 2:
Input: s = "rat"
Output: "art"
Explanation: The word "rat" becomes "art" after re-ordering it with the mentioned algorithm.

Example 3:
Input: s = "leetcode"
Output: "cdelotee"

Example 4:
Input: s = "ggggggg"
Output: "ggggggg"

Example 5:
Input: s = "spo"
Output: "ops"
*/
/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/


var sortString = function(s) {
  let res ='', map= new Map(), unique = [...new Set(s.split('').sort())];
    for(i in s){
        map.set(s[i],map.get(s[i])+1||1);
    }
     console.log(map)
        while(unique.length>0){
            for(let i=0;i<unique.length;i++){
                if(map.has(unique[i]) && map.get(unique[i])>0){
                    res+=unique[i]
                    map.set(unique[i],map.get(unique[i])-1);
                }else{
                    unique.splice(i,1);
                    i--;
                }
            }
			unique.reverse()
		}
    return res;
}
sortString(  s = "aaaabbbbcccc")


/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1470. Shuffle the Array
Easy
  Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].
  Return the array in the form [x1,y1,x2,y2,...,xn,yn].
Example 1:
  Input: nums = [2,5,1,3,4,7], n = 3
  Output: [2,3,5,4,1,7] 
  Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7].
Example 2:
  Input: nums = [1,2,3,4,4,3,2,1], n = 4
  Output: [1,4,2,3,3,2,4,1]
Example 3:
  Input: nums = [1,1,2,2], n = 2
  Output: [1,2,1,2]
    nums.splice(0, z)
    console.log(nums)
 */
 */
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var shuffle = function(nums, n) {
    let shuffle = [];
    let j = 0;
    for (let i = 0; i < n; i++) {
        [shuffle[j], shuffle[j + 1]] = [nums[i], nums[n + i]];
        j += 2;
    } 
    return shuffle;
};
shuffle(nums=[2,5,1,3,4, 7], n = 3);

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/    
/*
1480. Running Sum of 1d Array

Easy
Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i])
Return the running sum of nums.

Example 1:
Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].

Example 2:
Input: nums = [1,1,1,1,1]
Output: [1,2,3,4,5]
Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].

Example 3:
Input: nums = [3,1,2,10,1]
Output: [3,4,6,16,17]
 
Constraints:
1 <= nums.length <= 1000
-10^6 <= nums[i] <= 10^6

*/
/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var runningSum = function(nums) {
let sum = 0;
let runSum = [];
for(const x in nums){
sum+=parseFloat(nums[x]);
runSum.push(sum);
}
return runSum;
};



/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
1700. Number of Students Unable to Eat Lunch
Easy

The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.

The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:

If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.
Otherwise, they will leave it and go to the queue's end.
This continues until none of the queue students want to take the top sandwich and are thus unable to eat.

You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.


Example 1:

Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
Output: 0 
Explanation:
- Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].
- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].
- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].
- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].
- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].
Hence all students are able to eat.
Example 2:

Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
Output: 3
 

Constraints:

1 <= students.length, sandwiches.length <= 100
students.length == sandwiches.length
sandwiches[i] is 0 or 1.
students[i] is 0 or 1.
*/
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1528. Shuffle String
Easy
 Given a string s and an integer array indices of the same length.
 The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.
 Return the shuffled string.
Example 1:
  Input: s = "codeleet", indices = [4,5,6,7,0,2,1,3]
  Output: "leetcode"
  Explanation: As shown, "codeleet" becomes "leetcode" after shuffling.
Example 2:
  Input: s = "abc", indices = [0,1,2]
  Output: "abc"
  Explanation: After shuffling, each character remains in its position.
Example 3:
  Input: s = "aiohn", indices = [3,1,4,2,0]
  Output: "nihao"
Example 4:
  Input: s = "aaiougrt", indices = [4,0,2,6,7,3,1,5]
  Output: "arigatou"
Example 5:
  Input: s = "art", indices = [1,0,2]
  Output: "rat"
  


 */
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 


const restoreString = (s, arr) => (
    arr.reduce((accumulator, currentValue, index) => {
        accumulator[currentValue] = s[index];
        return accumulator;
    }, []).join("")
);

var restoreString = function(s, arr) {
let x = s.split('');
let result = [];
for (let i = 0; i < s.length; i++) {
  result[arr[i]] = x[i]
}
return result.join('')
};

restoreString(s = "aiohn", arr = [3,1,4,2,0])

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1790. Check if One String Swap Can Make Strings Equal
Easy
Balanced strings are those that have an equal quantity of 'L' and 'R' characters.
Given a balanced string s, split it in the maximum amount of balanced strings.
Return the maximum amount of split balanced strings.
Example 1:
  Input: s = "RLRRLLRLRL"
  Output: 4
  Explanation: s can be split into "RL", "RRLL", "RL", "RL", each substring contains same number of 'L' and 'R'.
Example 2:
  Input: s = "RLLLLRRRLR"
  Output: 3
  Explanation: s can be split into "RL", "LLLRRR", "LR", each substring contains same number of 'L' and 'R'.
Example 3:
  Input: s = "LLLLRRRR"
  Output: 1
  Explanation: s can be split into "LLLLRRRR".
Example 4:
  Input: s = "RLRRRLLRLL"
  Output: 2
  Explaination: s can be split into "RL", "RRRLLRLL", since each substring contains an equal number of 'L' and 'R'
 */
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 

var balancedStringSplit = function(s) {
    let stack = [];
    let count = 0;
    let first = s[0];
    for (let i = 0; i < s.length; i++) {
        if (s[i] === first) {
            stack.push(s[i]);
        } else {
            stack.pop();
        }
        if (!stack.length) {
            count++;
            if (s[i+1]) first = s[i+1];
        };
    }
    
    return count;
};
balancedStringSplit("RLLLLRRRLR")
**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1790. Check if One String Swap Can Make Strings Equal
Easy
You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.
Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.
Example 1:
  Input: s1 = "bank", s2 = "kanb"
  Output: true
  Explanation: For example, swap the first character with the last character of s2 to make "bank".
Example 2:
  Input: s1 = "attack", s2 = "defend"
  Output: false
  Explanation: It is impossible to make them equal with one string swap.
Example 3:
  Input: s1 = "kelb", s2 = "kelb"
  Output: true
  Explanation: The two strings are already equal, so no string swap operation is required.
Example 4:
  Input: s1 = "abcd", s2 = "dcba"
  Output: false
 */
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
/*
#1
var areAlmostEqual = function (s1, s2) {
  let miss =0;
 let one = s1.split('');
  let two = s2.split('');
  one.forEach((i, j)=> i!=two[j] ? miss=miss+1 : '')
  if(miss!=2 && miss!=0) return false
let obj1 = one.reduce((acc, i) => {
     if(!acc[i]) 
     acc[i]= 0; 
     acc[i]++;                   
    return acc;   
    }, {}
   );

let obj2 = two.reduce((acc, i) => {
    if(!acc[i]) 
     acc[i]= 0; 
     acc[i]++;                   
    return acc;   
    }, {}
   );
    if(Object.keys(obj1).sort().toString()!= Object.keys(obj2).sort().toString() ){return false}
    return true
}
#2

var areAlmostEqual = function(s1, s2) {
    if(s1 === s2) return true;
    let result='';
    
    for(let i=0;i<s1.length;i++)
        if(s1[i] !== s2[i]) result += s1[i]+s2[i];        
    
    return result.length === 4 && result[0]===result[3] && result[1] === result[2];
};
#3
var areAlmostEqual = function(s1, s2) {
    if(s1 === s2) return true;
    let miss = 0;
    for(var i = 0; i < s1.length; i++) {
        if(s1[i] !== s2[i]) {
            miss++;
        }
        if(!s2.includes(s1[i])) {
            return false;
        }
    }
        return (miss === 0 || miss === 2);
};
areAlmostEqual(s1 = "bank", s2 = "bank")


/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var countStudents = function (students, sandwiches) {
  let shift = students.length * sandwiches.length;
  for (i = 0; i < shift; i++) {
    if (students[0] != sandwiches[0]) {
      students.push(students.splice(0, 1)[0]);
    } else {
      sandwiches.splice(0, 1);
      students.splice(0, 1);
    }
  }
  return students.length;
};
countStudents([0,0,0,1,1,1,1,0,0,0], [1,0,1,0,0,1,1,0,0,0]);

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/

1800. Maximum Ascending Subarray Sum

Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.

A subarray is defined as a contiguous sequence of numbers in an array.

A subarray [numsl, numsl+1, ..., numsr-1, numsr] is ascending if for all i where l <= i < r, numsi < numsi+1. Note that a subarray of size 1 is ascending.

Example 1:

Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.
Example 2:

Input: nums = [10,20,30,40,50]
Output: 150
Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.
Example 3:

Input: nums = [12,17,15,13,10,11,12]
Output: 33
Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.
Example 4:

Input: nums = [100,10,1]
Output: 100
 

Constraints:

1 <= nums.length <= 100
1 <= nums[i] <= 100
*/

/**************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
var maxAscendingSum = function (nums) {
  let sum = 0;
  let count = [];
  for (let item = 0; item < nums.length; item++) {
    if (nums[item] < nums[item + 1] && sum >= nums[item] && nums[item] > nums[item - 1]) {
      sum += nums[item];
    } else if (nums[item] <= nums[item - 1] ||(nums[item] < nums[item + 1] && sum >= nums[item])
    ) {
      sum = nums[item];
    } else {
      sum += nums[item];
      count.push(sum);
    }
  }
  return Math.max(...count);
};

maxAscendingSum([12,17,15,13,10,11,12])
*/
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*
1832. Check if the Sentence Is Pangram
Easy
A pangram is a sentence where every letter of the English alphabet appears at least once.
Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise.
Example 1:
Input: sentence = "thequickbrownfoxjumpsoverthelazydog"
Output: true
Explanation: sentence contains at least one of every letter of the English alphabet.
Example 2:

Input: sentence = "leetcode"
Output: false

*/

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***********************************************************************************/
/*1848. Minimum Distance to the Target Element
Easy
Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that abs(x) is the absolute value of x.
Return abs(i - start).

It is guaranteed that target exists in nums.
Example 1:
Input: nums = [1,2,3,4,5], target = 5, start = 3
Output: 1
Explanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.

Example 2:
Input: nums = [1], target = 1, start = 0
Output: 0
Explanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.

Example 3:
Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0
Output: 0
Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.
 

Constraints: 1 <= nums.length <= 1000 1 <= nums[i] <= 104 0 <= start < nums.length
target is in nums.
/*************************************************************************************/
/************************************ANSWER********************************************/
/***********************************************************************************/ 
*/
var getMinDistance = function(nums, target, start) {
  let mySet = new Set();
  nums.forEach((x)=> x===start | x===target ? mySet.add(x): false);
  console.log(mySet)
};
getMinDistance([1,2,3,4,5], 5, 3)
//x===target mySet.add(x)
/**************************************************************************************/
/*************************************QUESTION********************************************/
/***************************************************************************************/
/*
1854. Maximum Population Year
Easy
You are given a 2D integer array logs where each logs[i] = [birthi, deathi] indicates the birth and death years of the ith person.
The population of some year x is the number of people alive during that year. The ith person is counted in year x's population if x is in the inclusive range [birthi, deathi - 1]. Note that the person is not counted in the year that they die.
Return the earliest year with the maximum population.

Example 1:
Input: logs = [[1993,1999],[2000,2010]]
Output: 1993
Explanation: The maximum population is 1, and 1993 is the earliest year with this population.

Example 2:
Input: logs = [[1950,1961],[1960,1971],[1970,1981]]
Output: 1960
Explanation: 
The maximum population is 2, and it had happened in years 1960 and 1970.
The earlier year between them is 1960.

/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/
const maximumPopulation = (logs) => {
    let m = new Map();
    for (const [birth, death] of logs) {
        for (let year = birth; year < death; year++) {
            m.set(year, m.get(year) + 1 || 1);
        }
    }
    m = new Map([...m].sort((a, b) => {
        if (a[1] == b[1]) return a[0] - b[0]; // if population same, smaller year comes first
        return b[1] - a[1]; // sort by population decreasing
    }));
    return m.keys().next().value;
};
maximumPopulation( logs = [[1982,1998],[2013,2042],[2010,2035],[2022,2050],[2047,2048]]);

/**************************************************************************************/
/*************************************QUESTION********************************************/
/***************************************************************************************/
/*
1859. Sorting the Sentence
Easy
A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters.
A sentence can be shuffled by appending the 1-indexed word position to each word then rearranging the words in the sentence.
For example, the sentence "This is a sentence" can be shuffled as "sentence4 a3 is2 This1" or "is2 sentence4 This1 a3".
Given a shuffled sentence s containing no more than 9 words, reconstruct and return the original sentence.

Example 1:
Input: s = "is2 sentence4 This1 a3"
Output: "This is a sentence"
Explanation: Sort the words in s to their original positions "This1 is2 a3 sentence4", then remove the numbers.
Example 2:
Input: s = "Myself2 Me1 I4 and3"
Output: "Me Myself and I"
Explanation: Sort the words in s to their original positions "Me1 Myself2 and3 I4", then remove the numbers.*./
/*************************************************************************************/
/************************************ANSWER********************************************/
/*********************************************************************************/
var sortSentence = function(s) {
return s.split(' ').sort((a,b) => a[a.length-1] - b[b.length-1]).join('').replace(/[0-9]/g, ' ').trim();

};
 
sortSentence("is2 sentence4 This1 a3")
